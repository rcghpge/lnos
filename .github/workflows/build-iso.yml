name: Build LnOS ISO

on:
  push:
    branches: [ main, ISO_Updates ]
    paths:
      - 'archiso/**'
      - 'scripts/**'
      - '.github/workflows/build-iso.yml'
      - 'build-iso.sh'
      - 'build-arm-image.sh'
  pull_request:
    branches: [ main, ISO ]
    paths:
      - 'archiso/**'
      - 'scripts/**'
      - '.github/workflows/build-iso.yml'
      - 'build-iso.sh'
      - 'build-arm-image.sh'
  workflow_dispatch:
    inputs:
      architecture:
        description: 'Target architecture'
        required: true
        default: 'both'
        type: choice
        options:
          - 'x86_64'
          - 'aarch64'
          - 'both'

# add write permissions
permissions:
  contents: write

jobs:
  build-x86_64:
    if: ${{ github.event.inputs.architecture == 'x86_64' || github.event.inputs.architecture == 'both' || github.event.inputs.architecture == '' }}
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Free up disk space
        run: |
          # Clean up to maximize available space
          sudo rm -rf /opt/hostedtoolcache || true
          sudo rm -rf /usr/share/dotnet || true
          sudo rm -rf /usr/local/lib/android || true
          sudo rm -rf /usr/local/share/boost || true
          sudo rm -rf "$AGENT_TOOLSDIRECTORY" || true
          sudo apt-get clean || true
          sudo docker system prune -af || true
          
          echo "Disk space after cleanup:"
          df -h

      - name: Build x86_64 ISO in container
        run: |
          # Use Docker with minimal required privileges for archiso
          docker run --rm --privileged \
            --cap-add=SYS_ADMIN \
            --cap-add=MKNOD \
            --device=/dev/loop-control \
            --device=/dev/loop0 \
            --device=/dev/loop1 \
            --device=/dev/loop2 \
            -v ${{ github.workspace }}:/workspace \
            -w /workspace \
            archlinux:latest \
            bash -c "
              # Monitor available space
              echo '=== Initial disk space ==='
              df -h
              
              # Install required packages efficiently
              pacman-key --init
              pacman-key --populate archlinux
              pacman -Syu --noconfirm --disable-download-timeout
              pacman -S --noconfirm --disable-download-timeout archiso
              
              echo '=== Disk space after package install ==='
              df -h
              
              # Clean package cache to save space
              pacman -Sc --noconfirm
              
              # Make scripts executable
              chmod +x build-iso.sh
              chmod +x archiso/airootfs/root/customize_airootfs.sh
              
              echo '=== Starting ISO build ==='
              # Build the ISO with output monitoring
              ./build-iso.sh x86_64 2>&1 | tee /tmp/build.log
              
              echo '=== Final disk space ==='
              df -h
              
              # Check if ISO was created
              if ls out/*.iso 1> /dev/null 2>&1; then
                echo '‚úÖ ISO build successful'
                ls -lh out/*.iso
              else
                echo '‚ùå ISO build failed'
                cat /tmp/build.log
                exit 1
              fi
            "

      - name: Upload x86_64 ISO artifact
        uses: actions/upload-artifact@v4
        with:
          name: lnos-x86_64-iso
          path: out/*.iso
          retention-days: 30

  build-aarch64:
    if: ${{ github.event.inputs.architecture == 'aarch64' || github.event.inputs.architecture == 'both' || github.event.inputs.architecture == '' }}
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Free up disk space for ARM build
        run: |
          # Clean up to maximize available space for ARM builds
          sudo rm -rf /opt/hostedtoolcache || true
          sudo rm -rf /usr/share/dotnet || true
          sudo rm -rf /usr/local/lib/android || true
          sudo rm -rf /usr/local/share/boost || true
          sudo apt-get clean || true
          sudo docker system prune -af || true
          
          echo "Disk space after cleanup:"
          df -h

      - name: Build aarch64 SD card images
        run: |
          # Build ARM64 SD card images with resource optimization
          docker run --rm --privileged \
            --cap-add=SYS_ADMIN \
            --cap-add=MKNOD \
            -v ${{ github.workspace }}:/workspace \
            -w /workspace \
            archlinux:latest \
            bash -c '
              # Monitor disk space throughout process
              echo "=== INITIAL DISK SPACE ==="
              df -h
              
              # Install minimal required tools efficiently
              pacman-key --init
              pacman-key --populate archlinux
              pacman -Syu --noconfirm --disable-download-timeout
              pacman -S --noconfirm --disable-download-timeout git wget parted dosfstools e2fsprogs
              
              echo "=== DISK SPACE AFTER PACKAGE INSTALL ==="
              df -h
              
              # Aggressive cleanup to save space
              pacman -Sc --noconfirm
              rm -rf /var/cache/pacman/pkg/*
              rm -rf /tmp/*
              
              echo "=== DISK SPACE AFTER CLEANUP ==="
              df -h
              
              # Make scripts executable
              chmod +x build-arm-image.sh build-arm-minimal.sh
              
              # Build minimal ARM64 SD card image only (saves space and time)
              echo "=== BUILDING MINIMAL ARM IMAGE ==="
              ./build-arm-minimal.sh rpi4 2>&1 | tee /tmp/arm-build.log
              
              echo "=== FINAL DISK SPACE ==="
              df -h
              
              # Verify build success
              if ls out/*.img 1> /dev/null 2>&1; then
                echo "‚úÖ ARM image build successful"
                ls -lh out/*.img
              else
                echo "‚ùå ARM image build failed"
                cat /tmp/arm-build.log
                exit 1
              fi
            '

      - name: Upload aarch64 SD card images
        uses: actions/upload-artifact@v4
        with:
          name: lnos-aarch64-sdcard
          path: out/*.img
          retention-days: 30

  create-release:
    if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/ISO') && github.event_name == 'push'
    needs: [build-x86_64, build-aarch64]
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download x86_64 ISO
        uses: actions/download-artifact@v4
        with:
          name: lnos-x86_64-iso
          path: ./isos/

      - name: Download aarch64 SD card image
        uses: actions/download-artifact@v4
        with:
          name: lnos-aarch64-sdcard
          path: ./isos/

      - name: Check file sizes for compression decision
        run: |
          cd ./isos/
          
          echo "=== CHECKING FILE SIZES ==="
          
          # Check ISO files
          for iso in *.iso; do
            if [ -f "$iso" ]; then
              size_mb=$(du -m "$iso" | cut -f1)
              size_human=$(du -h "$iso" | cut -f1)
              echo "ISO: $(basename "$iso")"
              echo "Size: ${size_human} (${size_mb} MB)"
              
              if [[ $size_mb -lt 1000 ]]; then
                echo "‚úÖ Under 1GB - no compression needed!"
                echo "Keeping $iso uncompressed"
              else
                echo "‚ùå Over 1GB - compressing with XZ"
                echo "Compressing $iso..."
                xz -9 -T 0 "$iso"
                echo "Compressed $(basename "$iso").xz"
              fi
              echo ""
            fi
          done
          
          # Check IMG files  
          for img in *.img; do
            if [ -f "$img" ]; then
              size_mb=$(du -m "$img" | cut -f1)
              size_human=$(du -h "$img" | cut -f1)
              echo "IMG: $(basename "$img")"
              echo "Size: ${size_human} (${size_mb} MB)"
              
              if [[ $size_mb -lt 1000 ]]; then
                echo "‚úÖ Under 1GB - no compression needed!"
                echo "Keeping $img uncompressed"
              else
                echo "‚ùå Over 1GB - compressing with XZ"
                echo "Compressing $img..."
                xz -9 -T 0 "$img"
                echo "Compressed $(basename "$img").xz"
              fi
              echo ""
            fi
          done
          
          echo "=== FINAL FILES ==="
          ls -lh

      - name: Sign release files with GPG
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/ISO'
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          cd ./isos/
          
          echo "üîê Setting up GPG environment..."
          
          # Verify secrets are available
          if [ -z "$GPG_PRIVATE_KEY" ]; then
            echo "‚ùå GPG_PRIVATE_KEY secret not set"
            exit 1
          fi
          
          if [ -z "$GPG_PASSPHRASE" ]; then
            echo "‚ùå GPG_PASSPHRASE secret not set"
            exit 1
          fi
          
          # Configure GPG for batch operation
          export GNUPGHOME=$(mktemp -d)
          echo "use-agent" > "$GNUPGHOME/gpg.conf"
          echo "pinentry-mode loopback" >> "$GNUPGHOME/gpg.conf"
          echo "batch" >> "$GNUPGHOME/gpg.conf"
          
          # Import the private key
          echo "üì• Importing GPG private key..."
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import
          
          # Get key ID and validate
          KEY_ID=$(gpg --list-secret-keys --with-colons | awk -F: '/^sec:/ {print $5}' | head -1)
          if [ -z "$KEY_ID" ]; then
            echo "‚ùå Failed to extract key ID from imported key"
            exit 1
          fi
          
          echo "üìã Using GPG key: $KEY_ID"
          
          # Verify this matches our expected key
          EXPECTED_KEY="9486759312876AD7"
          if [ "$KEY_ID" != "$EXPECTED_KEY" ]; then
            echo "‚ö†Ô∏è  Warning: Key ID $KEY_ID does not match expected $EXPECTED_KEY"
          fi
          
          # Test signing capability
          echo "test" | gpg --batch --yes \
            --pinentry-mode loopback \
            --passphrase "$GPG_PASSPHRASE" \
            --local-user "$KEY_ID" \
            --clearsign > /dev/null 2>&1 || {
            echo "‚ùå GPG signing test failed"
            exit 1
          }
          
          echo "‚úÖ GPG signing test successful"
          
          # Sign all release files
          SIGNED_COUNT=0
          for file in *.iso *.img *.xz; do
            if [ -f "$file" ]; then
              echo "üîè Signing: $file"
              
              # Create detached ASCII-armored signature
              if gpg --batch --yes \
                  --pinentry-mode loopback \
                  --passphrase "$GPG_PASSPHRASE" \
                  --local-user "$KEY_ID" \
                  --detach-sign \
                  --armor \
                  --output "${file}.asc" \
                  "$file"; then
                
                echo "‚úÖ Successfully signed: $file -> ${file}.asc"
                echo "üìù Signature size: $(wc -c < "${file}.asc") bytes"
                
                # Verify the signature immediately
                if gpg --verify "${file}.asc" "$file" >/dev/null 2>&1; then
                  echo "‚úÖ Signature verification successful for $file"
                  SIGNED_COUNT=$((SIGNED_COUNT + 1))
                else
                  echo "‚ùå Signature verification failed for $file"
                  exit 1
                fi
              else
                echo "‚ùå Failed to sign: $file"
                exit 1
              fi
            fi
          done
          
          echo ""
          echo "üéâ Successfully signed $SIGNED_COUNT files"
          echo ""
          echo "=== SIGNED FILES ==="
          ls -lh *.asc 2>/dev/null || echo "No signature files found"
          
          echo ""
          echo "=== GPG KEY INFO ==="
          gpg --list-keys "$KEY_ID" || echo "Key info not available"

      - name: Generate release tag
        id: tag
        run: |
          TAG="v$(date +'%Y.%m.%d')-$(git rev-parse --short HEAD)"
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          name: LnOS Release ${{ steps.tag.outputs.tag }}
          body: |
            ## LnOS Custom Arch Linux Distribution
            
            ![GPG Signed](https://img.shields.io/badge/GPG-Signed-brightgreen?style=for-the-badge&logo=gnupg)
            ![Security Verified](https://img.shields.io/badge/Security-Verified-blue?style=for-the-badge&logo=shield)
            ![Integrity Guaranteed](https://img.shields.io/badge/Integrity-Guaranteed-orange?style=for-the-badge&logo=checkmarx)
            
            **üîí This release is cryptographically signed for authenticity and integrity**
            
            This release contains custom minimal Arch Linux images with the LnOS installer.
            
            ### Features:
            - **Cryptographically signed** with GPG (Key: `9486759312876AD7`)
            - Minimal Arch Linux base system
            - Interactive package selection
            - Desktop environment choices (GNOME, KDE, Hyprland, DWM, TTY)
            - CSE and Custom installation profiles
            - Automated partitioning and installation
            
            ### Files Included:
            - **x86_64 ISO/IMG**: For VMs, Intel/AMD computers, and USB boot
            - **ARM64 IMG**: SD card image for Raspberry Pi 4 and ARM64 devices
            - **Digital Signatures**: `.asc` files for verifying authenticity
            
            **Note**: Large files (>1GB) are compressed with XZ to stay under GitHub's 2GB limit. Files under 1GB are uncompressed and ready to use.
            
            ### üõ°Ô∏è Security & Digital Signature Verification:
            
            > ‚ö†Ô∏è **IMPORTANT**: Always verify file signatures before use! All release files are digitally signed with GPG.
            
            **GPG Key Information:**
            - **Key ID**: `9486759312876AD7`
            - **Fingerprint**: `FF3B 2203 9FA1 CBC0 72E5 8967 9486 7593 1287 6AD7`
            - **Owner**: LnOS Development Team
            
            **Verification Methods:**
            ```bash
            # Quick verification (auto-imports key)
            curl -fsSL https://raw.githubusercontent.com/rcghpge/lnos/main/scripts/verify-signature.sh | bash -s -- <filename>
            
            # Manual verification
            curl -fsSL https://raw.githubusercontent.com/rcghpge/lnos/main/keys/lnos-public-key.asc | gpg --import
            gpg --verify <filename>.asc <filename>
            ```
            
            ### Checksums:
            ```
            $(cd isos && sha256sum * 2>/dev/null || echo "Checksums will be calculated...")
            ```
          files: ./isos/*
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
